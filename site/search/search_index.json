{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HLD: High Level Design document","title":"Home"},{"location":"HighLevelDesign/","text":"Connect4 Introduction Purpose The aim is to develop an interactive version of the game which the candidate and interviewer can play together. A simple, text-based, representation of the grid is encouraged. For example, you might use '.' for empty slots, and 'x' and 'o' for pieces of the two players. Players can input their turns via the REPL, or you can implement a simple API. A minimal version of the game should support: - a 6 x 7 grid - players play pieces sequentially - the game identifies winning turns and ends at that point Scope No UI. System Overview Nb. First create the StateManager. Then create the Board, providing callback references to the StateManager functions, so that when a Counter enters a Slot in the Board, a callback is made to the StateManager with details of the change. Documenting the Domain Process \"Initialise game\" Caused by connect4 start command Player 1 is instructed to take their turn by selecting a column Process \"Take turn\" Caused by Next-turn event being raised by the StateManager Player 1/2 takes turn by inputting the Column number they wish to drop their Counter into Process \"End state reached\" Caused by Game-won event being raised by StateManager System Context Provides a high-level view of the system and its interactions with external entities (users, other systems). External Entities Players: there will be two human players. Assumptions and Constraints Assumptions The game will be played on the same computer, with each Player taking it in turns to use the keyboard. Games do not need to be saved. Constraints The Board will comprise a 6 x 7 grid of Slots players play pieces sequentially the game identifies winning turns and ends at that point there are enough Counters to fill every Slot in the Board Architecture Diagram A visual representation of the system architecture, showing major components and their relationships. System Architecture Component Descriptions Player A Player may take a Counter from the remaining Counters and place it into any of the Columns of the Board. Board The Board is made up of Rows and Columns of Slots. Board { rows: Row[] columns: Column[] dropCounter(column: number, counter: Counter) } Slot A Slot is a single disk sized section of the Board. It can hold one Counter. Counters The set of all Counters. Counter A Counter is a coloured plastic disk which can fit into the Columns of the Board (at least in the physical game). There are enough Counters to fill every Slot in the Board. Colour: 'red' | 'yellow' Counter { colour: Colour getColour(): Colour } State Manager Checks to see if a winning state has occured. Go through each Slot. If a Slot has a Counter in it then perform the following checks: - Vertical line (ascending) check - Vertical line (descending) check - Horizontal line (left) check - Horizontal line (ascending) check - Diagonal line (ascending) check - Diagonal line (descending) check Data Flow Diagrams (DFD) Illustrates how data moves through the system. Use Case Diagrams Depicts the interactions between users and the system. Use Case Diagrams Deployment Diagram Shows how the software will be deployed across various hardware components or nodes. Design Considerations Assumptions Lists assumptions made during the design process. Constraints Identifies constraints that impact the design (e.g., hardware, software, regulatory). Dependencies Highlights dependencies on other systems or components. Design Principles Outlines the principles guiding the design (e.g., scalability, maintainability). Subsystems and Modules Subsystem Overview Provides a high-level description of each subsystem and its role within the overall system. Module Descriptions Detailed descriptions of each module within a subsystem, including their interfaces, functionality, and interconnections. Interface Design External Interfaces Describes interfaces with external systems, including APIs, communication protocols, and data formats. Internal Interfaces Details interfaces between internal components, specifying methods of interaction and data exchange. Data Design Data Model Describes the data entities, relationships, and data flow within the system. Database Design High-level description of the database schema, including tables, relationships, and key attributes. Security Considerations Security Architecture Overview of the system's security features and mechanisms. Authentication and Authorization Methods for ensuring secure access to the system. Data Protection Measures for protecting sensitive data. Performance Considerations Performance Requirements Expected performance metrics and benchmarks. Scalability Plan Strategies for scaling the system to handle increased load. Optimization Techniques Approaches for optimizing system performance. Error Handling and Logging Error Management Strategies for detecting, reporting, and handling errors. Logging Design of the logging mechanism for tracking system events and issues. Testing and Validation Testing Strategy Overview of the testing approach, including types of testing to be performed (unit, integration, system). Validation Criteria Criteria for validating that the system meets its requirements. Appendices Glossary Definitions of terms and acronyms used in the document. References List of references and sources used in the document. Change Log: Record of changes made to the document over time.","title":"Connect4"},{"location":"HighLevelDesign/#connect4","text":"","title":"Connect4"},{"location":"HighLevelDesign/#introduction","text":"","title":"Introduction"},{"location":"HighLevelDesign/#purpose","text":"The aim is to develop an interactive version of the game which the candidate and interviewer can play together. A simple, text-based, representation of the grid is encouraged. For example, you might use '.' for empty slots, and 'x' and 'o' for pieces of the two players. Players can input their turns via the REPL, or you can implement a simple API. A minimal version of the game should support: - a 6 x 7 grid - players play pieces sequentially - the game identifies winning turns and ends at that point","title":"Purpose"},{"location":"HighLevelDesign/#scope","text":"No UI.","title":"Scope"},{"location":"HighLevelDesign/#system-overview","text":"Nb. First create the StateManager. Then create the Board, providing callback references to the StateManager functions, so that when a Counter enters a Slot in the Board, a callback is made to the StateManager with details of the change.","title":"System Overview"},{"location":"HighLevelDesign/#documenting-the-domain","text":"Process \"Initialise game\" Caused by connect4 start command Player 1 is instructed to take their turn by selecting a column Process \"Take turn\" Caused by Next-turn event being raised by the StateManager Player 1/2 takes turn by inputting the Column number they wish to drop their Counter into Process \"End state reached\" Caused by Game-won event being raised by StateManager","title":"Documenting the Domain"},{"location":"HighLevelDesign/#system-context","text":"Provides a high-level view of the system and its interactions with external entities (users, other systems).","title":"System Context"},{"location":"HighLevelDesign/#external-entities","text":"Players: there will be two human players.","title":"External Entities"},{"location":"HighLevelDesign/#assumptions-and-constraints","text":"","title":"Assumptions and Constraints"},{"location":"HighLevelDesign/#assumptions","text":"The game will be played on the same computer, with each Player taking it in turns to use the keyboard. Games do not need to be saved.","title":"Assumptions"},{"location":"HighLevelDesign/#constraints","text":"The Board will comprise a 6 x 7 grid of Slots players play pieces sequentially the game identifies winning turns and ends at that point there are enough Counters to fill every Slot in the Board","title":"Constraints"},{"location":"HighLevelDesign/#architecture-diagram","text":"A visual representation of the system architecture, showing major components and their relationships.","title":"Architecture Diagram"},{"location":"HighLevelDesign/#system-architecture","text":"","title":"System Architecture"},{"location":"HighLevelDesign/#component-descriptions","text":"","title":"Component Descriptions"},{"location":"HighLevelDesign/#player","text":"A Player may take a Counter from the remaining Counters and place it into any of the Columns of the Board.","title":"Player"},{"location":"HighLevelDesign/#board","text":"The Board is made up of Rows and Columns of Slots. Board { rows: Row[] columns: Column[] dropCounter(column: number, counter: Counter) }","title":"Board"},{"location":"HighLevelDesign/#slot","text":"A Slot is a single disk sized section of the Board. It can hold one Counter.","title":"Slot"},{"location":"HighLevelDesign/#counters","text":"The set of all Counters.","title":"Counters"},{"location":"HighLevelDesign/#counter","text":"A Counter is a coloured plastic disk which can fit into the Columns of the Board (at least in the physical game). There are enough Counters to fill every Slot in the Board. Colour: 'red' | 'yellow' Counter { colour: Colour getColour(): Colour }","title":"Counter"},{"location":"HighLevelDesign/#state-manager","text":"Checks to see if a winning state has occured. Go through each Slot. If a Slot has a Counter in it then perform the following checks: - Vertical line (ascending) check - Vertical line (descending) check - Horizontal line (left) check - Horizontal line (ascending) check - Diagonal line (ascending) check - Diagonal line (descending) check","title":"State Manager"},{"location":"HighLevelDesign/#data-flow-diagrams-dfd","text":"Illustrates how data moves through the system.","title":"Data Flow Diagrams (DFD)"},{"location":"HighLevelDesign/#use-case-diagrams","text":"Depicts the interactions between users and the system.","title":"Use Case Diagrams"},{"location":"HighLevelDesign/#use-case-diagrams_1","text":"","title":"Use Case Diagrams"},{"location":"HighLevelDesign/#deployment-diagram","text":"Shows how the software will be deployed across various hardware components or nodes.","title":"Deployment Diagram"},{"location":"HighLevelDesign/#design-considerations","text":"","title":"Design Considerations"},{"location":"HighLevelDesign/#assumptions_1","text":"Lists assumptions made during the design process.","title":"Assumptions"},{"location":"HighLevelDesign/#constraints_1","text":"Identifies constraints that impact the design (e.g., hardware, software, regulatory).","title":"Constraints"},{"location":"HighLevelDesign/#dependencies","text":"Highlights dependencies on other systems or components.","title":"Dependencies"},{"location":"HighLevelDesign/#design-principles","text":"Outlines the principles guiding the design (e.g., scalability, maintainability).","title":"Design Principles"},{"location":"HighLevelDesign/#subsystems-and-modules","text":"","title":"Subsystems and Modules"},{"location":"HighLevelDesign/#subsystem-overview","text":"Provides a high-level description of each subsystem and its role within the overall system.","title":"Subsystem Overview"},{"location":"HighLevelDesign/#module-descriptions","text":"Detailed descriptions of each module within a subsystem, including their interfaces, functionality, and interconnections.","title":"Module Descriptions"},{"location":"HighLevelDesign/#interface-design","text":"","title":"Interface Design"},{"location":"HighLevelDesign/#external-interfaces","text":"Describes interfaces with external systems, including APIs, communication protocols, and data formats.","title":"External Interfaces"},{"location":"HighLevelDesign/#internal-interfaces","text":"Details interfaces between internal components, specifying methods of interaction and data exchange.","title":"Internal Interfaces"},{"location":"HighLevelDesign/#data-design","text":"","title":"Data Design"},{"location":"HighLevelDesign/#data-model","text":"Describes the data entities, relationships, and data flow within the system.","title":"Data Model"},{"location":"HighLevelDesign/#database-design","text":"High-level description of the database schema, including tables, relationships, and key attributes.","title":"Database Design"},{"location":"HighLevelDesign/#security-considerations","text":"","title":"Security Considerations"},{"location":"HighLevelDesign/#security-architecture","text":"Overview of the system's security features and mechanisms.","title":"Security Architecture"},{"location":"HighLevelDesign/#authentication-and-authorization","text":"Methods for ensuring secure access to the system.","title":"Authentication and Authorization"},{"location":"HighLevelDesign/#data-protection","text":"Measures for protecting sensitive data.","title":"Data Protection"},{"location":"HighLevelDesign/#performance-considerations","text":"","title":"Performance Considerations"},{"location":"HighLevelDesign/#performance-requirements","text":"Expected performance metrics and benchmarks.","title":"Performance Requirements"},{"location":"HighLevelDesign/#scalability-plan","text":"Strategies for scaling the system to handle increased load.","title":"Scalability Plan"},{"location":"HighLevelDesign/#optimization-techniques","text":"Approaches for optimizing system performance.","title":"Optimization Techniques"},{"location":"HighLevelDesign/#error-handling-and-logging","text":"","title":"Error Handling and Logging"},{"location":"HighLevelDesign/#error-management","text":"Strategies for detecting, reporting, and handling errors.","title":"Error Management"},{"location":"HighLevelDesign/#logging","text":"Design of the logging mechanism for tracking system events and issues.","title":"Logging"},{"location":"HighLevelDesign/#testing-and-validation","text":"","title":"Testing and Validation"},{"location":"HighLevelDesign/#testing-strategy","text":"Overview of the testing approach, including types of testing to be performed (unit, integration, system).","title":"Testing Strategy"},{"location":"HighLevelDesign/#validation-criteria","text":"Criteria for validating that the system meets its requirements.","title":"Validation Criteria"},{"location":"HighLevelDesign/#appendices","text":"","title":"Appendices"},{"location":"HighLevelDesign/#glossary","text":"Definitions of terms and acronyms used in the document.","title":"Glossary"},{"location":"HighLevelDesign/#references","text":"List of references and sources used in the document. Change Log: Record of changes made to the document over time.","title":"References"}]}